#!/bin/bash

# Универсальный скрипт настройки моста для Void Linux
# Создает мост между Wi-Fi и Ethernet с DHCP для подключенных устройств
# Обеспечивает двусторонний доступ к портам между устройствами

CONFIG_FILE="/etc/ethernet-bridge.conf"

WIFI_INTERFACE=""
ETH_INTERFACE=""
BRIDGE_NAME="br0"
BRIDGE_IP="192.168.100.1/24"
TEMP_DHCP_CONFIG="/tmp/dhcp_bridge.conf"

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        print_status "Загрузка конфигурации из $CONFIG_FILE"
        source "$CONFIG_FILE"
    else
        cat > "$CONFIG_FILE" << EOF
# Configuration for ethernet-bridge
# Uncomment and modify the following lines as needed

# NETWORK CONFIGURATION
# WIFI_INTERFACE="wlan0"
# ETH_INTERFACE="eth0"
# BRIDGE_NAME="br0"
# BRIDGE_IP="192.168.100.1/24"

# DNS CONFIGURATION
# DNS_SERVER="8.8.8.8,8.8.4.4"

# BANDWIDTH LIMIT CONFIGURATION
# BANDWIDTH_LIMIT=""

# STATIC IP CONFIGURATION
# Format: STATIC_IP_MAC="AA:BB:CC:DD:EE:FF,192.168.100.100"
# STATIC_IP_MAC2="00:11:22:33:44:55,192.168.100.101"

# PORT CONFIGURATION
# Format: OPEN_PORTS="80,443,8000,8080"
EOF
        print_status "Создан файл конфигурации по умолчанию: $CONFIG_FILE"
    fi

    : ${DNS_SERVER:=8.8.8.8,8.8.4.4}
    : ${BANDWIDTH_LIMIT:=}
    : ${OPEN_PORTS:=}
}

detect_init_system() {
    if [ -d "/run/systemd/system" ] || [ -f "/usr/lib/systemd/systemd" ] || [ -f "/lib/systemd/systemd" ]; then
        echo "systemd"
    elif [ -f "/etc/init.d/crond" ] || [ -d "/etc/init.d" ]; then
        if [ -f "/sbin/openrc" ] || [ -d "/etc/openrc" ]; then
            echo "openrc"
        elif [ -f "/usr/bin/s6-rc-status" ] || [ -d "/etc/s6" ]; then
            echo "s6"
        elif [ -f "/run/runit/runsvdir/current" ] || [ -f "/etc/sv" ]; then
            echo "runit"
        else
            echo "sysv"
        fi
    else
        if [ -f "/bin/runit" ]; then
            echo "runit"
        elif [ -f "/sbin/openrc" ]; then
            echo "openrc"
        elif [ -f "/usr/bin/s6-rc-status" ]; then
            echo "s6"
        else
            echo "systemd"
        fi
    fi
}

create_systemd_service() {
    local service_file="/etc/systemd/system/ethernet-bridge.service"

    cat > "$service_file" << EOF
[Unit]
Description=Ethernet Bridge Service
After=network.target
Wants=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/ethernet-bridge start
ExecStop=/usr/local/bin/ethernet-bridge stop
RemainAfterExit=yes
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable ethernet-bridge.service
    print_status "Служба systemd создана и включена"
}

create_openrc_service() {
    local init_file="/etc/init.d/ethernet-bridge"

    cat > "$init_file" << 'EOF'
#!/sbin/openrc-run

description="Ethernet Bridge Service"
depend() {
    need net
    after net
}

start() {
    ebegin "Starting ethernet bridge"
    /usr/local/bin/ethernet-bridge start
    eend $?
}

stop() {
    ebegin "Stopping ethernet bridge"
    /usr/local/bin/ethernet-bridge stop
    eend $?
}
EOF

    chmod +x "$init_file"
    rc-update add ethernet-bridge default
    print_status "Служба OpenRC создана и включена"
}

create_s6_service() {
    local service_dir="/etc/s6/ethernet-bridge"
    mkdir -p "$service_dir"

    cat > "$service_dir/run" << 'EOF'
#!/bin/execlineb -S0
if { s6-test -f /usr/local/bin/ethernet-bridge }
backtick U { pipeline { s6-envuidgid root s6-applyuidgid -u root -g root } }
s6-setuidgid root
/usr/local/bin/ethernet-bridge start
EOF

    chmod +x "$service_dir/run"
    print_status "Служба s6 создана. Добавьте в автозапуск вручную, если требуется"
}

create_runit_service() {
    local service_dir="/etc/sv/ethernet-bridge"
    mkdir -p "$service_dir"

    cat > "$service_dir/run" << 'EOF'
#!/bin/sh
exec 2>&1
exec /usr/local/bin/ethernet-bridge start
EOF

    chmod +x "$service_dir/run"

    cat > "$service_dir/finish" << 'EOF'
#!/bin/sh
exec /usr/local/bin/ethernet-bridge stop
EOF

    chmod +x "$service_dir/finish"

    if [ -d "/var/service" ]; then
        ln -sf "$service_dir" /var/service/
        print_status "Служба runit создана и включена"
    else
        print_status "Служба runit создана. Свяжите с /var/service/ вручную для автозапуска"
    fi
}

create_sysv_service() {
    local init_file="/etc/init.d/ethernet-bridge"

    cat > "$init_file" << 'EOF'
#!/bin/bash
# ethernet-bridge        Ethernet Bridge Service
# chkconfig: 35 80 20
# description: Ethernet Bridge Service

. /etc/rc.d/init.d/functions

case "$1" in
    start)
        echo -n "Starting ethernet bridge: "
        /usr/local/bin/ethernet-bridge start
        echo_success
        echo
        ;;
    stop)
        echo -n "Shutting down ethernet bridge: "
        /usr/local/bin/ethernet-bridge stop
        echo_success
        echo
        ;;
    restart)
        $0 stop
        $0 start
        ;;
    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
        ;;
esac
EOF

    chmod +x "$init_file"

    if command -v chkconfig >/dev/null 2>&1; then
        chkconfig --add ethernet-bridge
        chkconfig ethernet-bridge on
    elif command -v update-rc.d >/dev/null 2>&1; then
        update-rc.d ethernet-bridge defaults
    else
        print_status "Служба SysV создана. Настройте автозапуск вручную"
        return
    fi

    print_status "Служба SysV создана и включена"
}

create_autostart() {
    local init_system=$(detect_init_system)
    print_status "Обнаружена init-система: $init_system"

    case "$init_system" in
        "systemd")
            create_systemd_service
            ;;
        "openrc")
            create_openrc_service
            ;;
        "s6")
            create_s6_service
            ;;
        "runit")
            create_runit_service
            ;;
        "sysv")
            create_sysv_service
            ;;
        *)
            print_error "Неизвестная или неподдерживаемая init-система: $init_system"
            return 1
            ;;
    esac
}

remove_autostart() {
    local init_system=$(detect_init_system)
    print_status "Удаление автозапуска для init-системы: $init_system"

    case "$init_system" in
        "systemd")
            systemctl stop ethernet-bridge 2>/dev/null || true
            systemctl disable ethernet-bridge.service 2>/dev/null || true
            rm -f /etc/systemd/system/ethernet-bridge.service
            systemctl daemon-reload
            ;;
        "openrc")
            rc-service ethernet-bridge stop 2>/dev/null || true
            rc-update del ethernet-bridge default 2>/dev/null || true
            rm -f /etc/init.d/ethernet-bridge
            ;;
        "runit")
            if [ -L "/var/service/ethernet-bridge" ]; then
                rm -f /var/service/ethernet-bridge
            fi
            rm -rf /etc/sv/ethernet-bridge
            ;;
        "sysv")
            if command -v chkconfig >/dev/null 2>&1; then
                chkconfig ethernet-bridge off 2>/dev/null || true
                chkconfig --del ethernet-bridge 2>/dev/null || true
            elif command -v update-rc.d >/dev/null 2>&1; then
                update-rc.d -f ethernet-bridge remove 2>/dev/null || true
            fi
            rm -f /etc/init.d/ethernet-bridge
            ;;
        *)
            print_error "Неизвестная или неподдерживаемая init-система: $init_system"
            return 1
            ;;
    esac

    print_status "Автозапуск удален для $init_system"
}

install_zsh_completion() {
    local completion_dir="/usr/share/zsh/site-functions"
    local completion_file="_ethernet-bridge"

    mkdir -p "$completion_dir"

    cat > "$completion_dir/$completion_file" << 'EOF'
#compdef ethernet-bridge

local -a commands

commands=(
    "start:Запустить мост с DHCP и двусторонним доступом к портам"
    "stop:Остановить мост и очистить все настройки"
    "restart:Перезапустить мост с нуля"
    "status:Проверить статус"
    "devices:Показать подключенные устройства"
    "rules:Показать активные правила iptables"
    "port:Управление портами"
    "static-ip:Назначить статический IP для MAC-адреса"
    "limit-bandwidth:Ограничить пропускную способность"
    "remove-bandwidth-limit:Снять ограничение пропускной способности"
    "logs:Показать сетевые логи"
    "set-dns:Установить DNS-сервер для подключенных устройств"
    "autostart:Управление автозапуском"
)

local -a port_subcommands
port_subcommands=(
    "open:Открыть конкретный порт для доступа к подключенным устройствам"
    "close:Закрыть конкретный порт для подключенных устройств"
    "list-open:Показать открытые порты для подключенных устройств"
)

local -a autostart_subcommands
autostart_subcommands=(
    "enable:Включить автозапуск при загрузке системы"
    "disable:Отключить автозапуск при загрузке системы"
)

_arguments -C \
    '1: :->cmds' \
    '*::arg:->args'

case $state in
    cmds)
        _describe 'command' commands
        ;;
    args)
        case $words[2] in
            port)
                _describe 'port subcommand' port_subcommands
                ;;
            autostart)
                _describe 'autostart subcommand' autostart_subcommands
                ;;
            static-ip)
                _message 'Введите MAC-адрес и IP-адрес'
                ;;
            limit-bandwidth)
                _message 'Введите значение ограничения (например, 10mbit)'
                ;;
            set-dns)
                _message 'Введите IP-адрес DNS-сервера'
                ;;
        esac
        ;;
esac
EOF

    print_status "Автодополнение для zsh установлено в $completion_dir/$completion_file"

    compinit 2>/dev/null || true
    print_status "Кэш автодополнения zsh обновлен"
}

install_fish_completion() {
    local completion_dir="/usr/share/fish/completions"
    local completion_file="ethernet-bridge.fish"

    mkdir -p "$completion_dir"

    cat > "$completion_dir/$completion_file" << 'EOF'
# Команды для ethernet-bridge
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "start" -d "Запустить мост с DHCP и двусторонним доступом к портам"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "stop" -d "Остановить мост и очистить все настройки"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "restart" -d "Перезапустить мост с нуля"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "status" -d "Проверить статус"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "devices" -d "Показать подключенные устройства"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "rules" -d "Показать активные правила iptables"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "port" -d "Управление портами"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "static-ip" -d "Назначить статический IP для MAC-адреса"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "limit-bandwidth" -d "Ограничить пропускную способность"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "remove-bandwidth-limit" -d "Снять ограничение пропускной способности"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "logs" -d "Показать сетевые логи"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "set-dns" -d "Установить DNS-сервер для подключенных устройств"
complete -c ethernet-bridge -f -n "__fish_use_subcommand" -a "autostart" -d "Управление автозапуском"

# Подкоманды для port
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from port" -a "open" -d "Открыть конкретный порт для доступа к подключенным устройствам"
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from port" -a "close" -d "Закрыть конкретный порт для подключенных устройств"
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from port" -a "list-open" -d "Показать открытые порты для подключенных устройств"

# Подкоманды для autostart
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from autostart" -a "enable" -d "Включить автозапуск при загрузке системы"
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from autostart" -a "disable" -d "Отключить автозапуск при загрузке системы"

# Параметры для static-ip
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from static-ip" -a "" -d "MAC-адрес"

# Параметры для limit-bandwidth
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from limit-bandwidth" -a "" -d "Ограничение скорости (например, 10mbit)"

# Параметры для set-dns
complete -c ethernet-bridge -A -f -n "__fish_seen_subcommand_from set-dns" -a "" -d "IP-адрес DNS-сервера"
EOF

    print_status "Автодополнение для fish установлено в $completion_dir/$completion_file"
}

restart_bridge_if_needed() {
    if ip link show "$BRIDGE_NAME" &>/dev/null; then
        print_status "Перезапуск моста для применения изменений..."

        local temp_dns="$DNS_SERVER"
        local temp_bandwidth_limit="$BANDWIDTH_LIMIT"
        local temp_open_ports="$OPEN_PORTS"

        stop_bridge_dhcp

        sleep 2

        setup_bridge_dhcp

        print_status "Мост перезапущен с новыми настройками"
    else
        print_status "Мост не запущен, перезапуск не требуется"
    fi
}

apply_port_config() {
    if [ -n "${OPEN_PORTS:-}" ]; then
        print_status "Применение настроек открытых портов из конфига: $OPEN_PORTS"

        IFS=',' read -ra ports <<< "$OPEN_PORTS"
        for port in "${ports[@]}"; do
            if [ -n "$port" ]; then
                open_port "$port" 2>/dev/null || true
            fi
        done
    fi
}

print_status() {
    echo -e "\033[0;32m[INFO]\033[0m $1"
}

print_error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        print_error "Запустите скрипт от root: sudo $0 $*"
        exit 1
    fi
}

check_dependencies() {
    local missing_commands=()

    if ! command -v brctl &> /dev/null; then
        missing_commands+=("bridge-utils")
    fi

    if ! command -v dnsmasq &> /dev/null; then
        missing_commands+=("dnsmasq")
    fi

    if ! command -v iptables &> /dev/null; then
        missing_commands+=("iptables")
    fi

    if [ ${#missing_commands[@]} -ne 0 ]; then
        print_error "Отсутствующие зависимости: ${missing_commands[*]}"
        print_error "Установите их вручную, используя ваш пакетный менеджер:"
        print_error "  - Debian/Ubuntu: apt install bridge-utils dnsmasq iptables"
        print_error "  - Red Hat/CentOS/Fedora: dnf install bridge-utils dnsmasq iptables"
        print_error "  - Arch Linux: pacman -S bridge-utils dnsmasq iptables"
        print_error "  - Void Linux: xbps-install -S bridge-utils dnsmasq iptables"
        exit 1
    fi
}

save_config() {
    local config_backup="$CONFIG_FILE.backup"
    cp "$CONFIG_FILE" "$config_backup" 2>/dev/null || true

    {
        echo "# Configuration for ethernet-bridge"
        echo "# Generated on $(date)"
        echo ""
        echo "# NETWORK CONFIGURATION"
        echo "# WIFI_INTERFACE=\"$WIFI_INTERFACE\""
        echo "# ETH_INTERFACE=\"$ETH_INTERFACE\""
        echo "# BRIDGE_NAME=\"$BRIDGE_NAME\""
        echo "# BRIDGE_IP=\"$BRIDGE_IP\""
        echo ""
        echo "# DNS CONFIGURATION"
        [ -n "$DNS_SERVER" ] && echo "DNS_SERVER=\"$DNS_SERVER\"" || echo "# DNS_SERVER=\"8.8.8.8,8.8.4.4\""
        echo ""
        echo "# BANDWIDTH LIMIT CONFIGURATION"
        [ -n "$BANDWIDTH_LIMIT" ] && echo "BANDWIDTH_LIMIT=\"$BANDWIDTH_LIMIT\"" || echo "# BANDWIDTH_LIMIT=\"\""
        echo ""
        echo "# STATIC IP CONFIGURATION"
        if [ -n "${STATIC_IP_MAC:-}" ]; then
            echo "STATIC_IP_MAC=\"${STATIC_IP_MAC}\""
        fi
        if [ -n "${STATIC_IP_MAC2:-}" ]; then
            echo "STATIC_IP_MAC2=\"${STATIC_IP_MAC2}\""
        fi
        if [ -n "${STATIC_IP_MAC3:-}" ]; then
            echo "STATIC_IP_MAC3=\"${STATIC_IP_MAC3}\""
        fi
        if [ -n "${STATIC_IP_MAC4:-}" ]; then
            echo "STATIC_IP_MAC4=\"${STATIC_IP_MAC4}\""
        fi
        if [ -n "${STATIC_IP_MAC5:-}" ]; then
            echo "STATIC_IP_MAC5=\"${STATIC_IP_MAC5}\""
        fi
        echo "# Если нужно больше статических IP, добавьте их вручную"
        echo ""
        echo "# PORT CONFIGURATION"
        [ -n "${OPEN_PORTS:-}" ] && echo "OPEN_PORTS=\"${OPEN_PORTS}\"" || echo "# OPEN_PORTS=\"80,443,8000,8080\""
    } > "$CONFIG_FILE"

    print_status "Конфигурация сохранена в $CONFIG_FILE"
    print_status "Резервная копия старой конфигурации: $config_backup"
}

get_command_description() {
    local cmd="$1"
    case "$cmd" in
        "start")
            echo "запустить мост с DHCP и двусторонним доступом к портам"
            ;;
        "stop")
            echo "остановить мост и очистить все настройки"
            ;;
        "restart")
            echo "перезапустить мост с нуля"
            ;;
        "status")
            echo "проверить статус"
            ;;
        "devices")
            echo "показать подключенные устройства"
            ;;
        "rules")
            echo "показать активные правила iptables"
            ;;
        "port")
            echo "управление портами (open, close, list-open)"
            ;;
        "static-ip")
            echo "назначить статический IP для MAC-адреса"
            ;;
        "limit-bandwidth")
            echo "ограничить пропускную способность"
            ;;
        "remove-bandwidth-limit")
            echo "снять ограничение пропускной способности"
            ;;
        "logs")
            echo "показать сетевые логи"
            ;;
        "set-dns")
            echo "установить DNS-сервер для подключенных устройств"
            ;;
        "autostart")
            echo "управление автозапуском (enable, disable)"
            ;;
        *)
            echo "неизвестная команда: $cmd"
            return 1
            ;;
    esac
}

show_command_info() {
    local cmd="$1"
    if [ -z "$cmd" ]; then
        print_error "Использование: $0 info <команда>"
        return 1
    fi

    local description=$(get_command_description "$cmd")
    if [ $? -eq 0 ]; then
        echo "$description"
    else
        print_error "$description"
        return 1
    fi
}

cleanup_existing_bridge() {
    print_status "Проверка существующего моста и очистка конфликтов..."

    if ip link show "$BRIDGE_NAME" &>/dev/null; then
        print_status "Мост $BRIDGE_NAME уже существует, останавливаем и удаляем..."
        ip link set "$BRIDGE_NAME" down 2>/dev/null || true
        brctl delif "$BRIDGE_NAME" "$ETH_INTERFACE" 2>/dev/null || true
        brctl delbr "$BRIDGE_NAME" 2>/dev/null || true
    fi

    BRIDGES=$(brctl show 2>/dev/null | grep -E "\s+$ETH_INTERFACE\s+" | awk '{print $1}' | head -1)
    if [ -n "$BRIDGES" ]; then
        print_status "Интерфейс $ETH_INTERFACE уже подключен к мосту $BRIDGES, отключаем..."
        for BRIDGE in $BRIDGES; do
            print_status "Отключение интерфейса $ETH_INTERFACE от моста $BRIDGE"
            brctl delif "$BRIDGE" "$ETH_INTERFACE" 2>/dev/null || true
        done
    fi

    CONFLICTING_INTERFACE=$(ip addr show 2>/dev/null | grep -B 1 "$BRIDGE_IP" | head -1 | awk '{print $2}' | sed 's/://')
    if [ -n "$CONFLICTING_INTERFACE" ] && [ "$CONFLICTING_INTERFACE" != "$BRIDGE_NAME" ]; then
        print_status "IP $BRIDGE_IP уже назначен интерфейсу $CONFLICTING_INTERFACE, освобождаем..."
        ip addr del "$BRIDGE_IP" dev "$CONFLICTING_INTERFACE" 2>/dev/null || true
    fi
}

detect_interfaces() {
    print_status "Определение сетевых интерфейсов..."

    for iface in $(ls /sys/class/net/); do
        if [[ $iface =~ ^wlan[0-9]+|^wlp[0-9]+ ]]; then
            if ip addr show $iface | grep -q 'inet '; then
                WIFI_INTERFACE=$iface
                break
            fi
        fi
    done

    for iface in $(ls /sys/class/net/); do
        if [[ $iface =~ ^eth[0-9]+|^enp[0-9]+|^eno[0-9]+ ]]; then
            ETH_INTERFACE=$iface
            break
        fi
    done

    if [ -z "$WIFI_INTERFACE" ] || [ -z "$ETH_INTERFACE" ]; then
        print_error "Не удалось автоматически определить интерфейсы"
        read -p "Введите Wi-Fi интерфейс (например, wlan0): " WIFI_INTERFACE
        read -p "Введите Ethernet интерфейс (например, eth0): " ETH_INTERFACE
    else
        print_status "Найден Wi-Fi: $WIFI_INTERFACE, Ethernet: $ETH_INTERFACE"
    fi
}

setup_bridge_dhcp() {
    print_status "Настройка моста с DHCP..."

    cleanup_existing_bridge

    pkill -f "dnsmasq.*dhcp_bridge.conf" 2>/dev/null || true

    brctl addbr $BRIDGE_NAME 2>/dev/null || true
    brctl addif $BRIDGE_NAME $ETH_INTERFACE 2>/dev/null
    brctl stp $BRIDGE_NAME on 2>/dev/null

    ip addr add $BRIDGE_IP dev $BRIDGE_NAME 2>/dev/null
    ip link set $BRIDGE_NAME up 2>/dev/null

    echo 1 > /proc/sys/net/ipv4/ip_forward
    if ! grep -q "net.ipv4.ip_forward=1" /etc/sysctl.conf; then
        echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
    fi

    iptables -t nat -A POSTROUTING -o $WIFI_INTERFACE -j MASQUERADE 2>/dev/null

    iptables -A FORWARD -i $BRIDGE_NAME -o $WIFI_INTERFACE -j ACCEPT 2>/dev/null
    iptables -A FORWARD -i $WIFI_INTERFACE -o $BRIDGE_NAME -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null

    iptables -A FORWARD -i $WIFI_INTERFACE -o $BRIDGE_NAME -d 192.168.100.0/24 -j ACCEPT 2>/dev/null

    iptables -A FORWARD -i $BRIDGE_NAME -o $WIFI_INTERFACE -s 192.168.100.0/24 -j ACCEPT 2>/dev/null

    iptables -A INPUT -i $BRIDGE_NAME -j ACCEPT 2>/dev/null
    iptables -A OUTPUT -o $BRIDGE_NAME -j ACCEPT 2>/dev/null

    iptables -A FORWARD -p tcp -s 192.168.100.0/24 -j ACCEPT 2>/dev/null
    iptables -A FORWARD -p udp -s 192.168.100.0/24 -j ACCEPT 2>/dev/null
    iptables -A FORWARD -p tcp -d 192.168.100.0/24 -j ACCEPT 2>/dev/null
    iptables -A FORWARD -p udp -d 192.168.100.0/24 -j ACCEPT 2>/dev/null

    cat > $TEMP_DHCP_CONFIG << EOF
interface=$BRIDGE_NAME
dhcp-range=192.168.100.100,192.168.100.200,12h
dhcp-option=option:router,192.168.100.1
dhcp-option=option:dns-server,${DNS_SERVER:-8.8.8.8,8.8.4.4}
log-dhcp
EOF

    if [ -f /etc/dnsmasq.conf ] && [ -s /etc/dnsmasq.conf ]; then
        grep "^dhcp-host=" /etc/dnsmasq.conf >> $TEMP_DHCP_CONFIG 2>/dev/null || true
    fi

    if [ -n "${STATIC_IP_MAC:-}" ]; then
        echo "dhcp-host=$(echo ${STATIC_IP_MAC} | cut -d',' -f1),$(echo ${STATIC_IP_MAC} | cut -d',' -f2)" >> $TEMP_DHCP_CONFIG
    fi
    if [ -n "${STATIC_IP_MAC2:-}" ]; then
        echo "dhcp-host=$(echo ${STATIC_IP_MAC2} | cut -d',' -f1),$(echo ${STATIC_IP_MAC2} | cut -d',' -f2)" >> $TEMP_DHCP_CONFIG
    fi
    if [ -n "${STATIC_IP_MAC3:-}" ]; then
        echo "dhcp-host=$(echo ${STATIC_IP_MAC3} | cut -d',' -f1),$(echo ${STATIC_IP_MAC3} | cut -d',' -f2)" >> $TEMP_DHCP_CONFIG
    fi
    if [ -n "${STATIC_IP_MAC4:-}" ]; then
        echo "dhcp-host=$(echo ${STATIC_IP_MAC4} | cut -d',' -f1),$(echo ${STATIC_IP_MAC4} | cut -d',' -f2)" >> $TEMP_DHCP_CONFIG
    fi
    if [ -n "${STATIC_IP_MAC5:-}" ]; then
        echo "dhcp-host=$(echo ${STATIC_IP_MAC5} | cut -d',' -f1),$(echo ${STATIC_IP_MAC5} | cut -d',' -f2)" >> $TEMP_DHCP_CONFIG
    fi

    cp $TEMP_DHCP_CONFIG /etc/dnsmasq.conf

    mkdir -p /var/lib/misc

    dnsmasq -C /etc/dnsmasq.conf

    print_status "Мост настроен! Подключенные устройства получат IP автоматически"

    if [ -n "${BANDWIDTH_LIMIT:-}" ]; then
        print_status "Применение ограничения пропускной способности: $BANDWIDTH_LIMIT"
        limit_bandwidth "$BANDWIDTH_LIMIT"
    fi

    apply_port_config
}

stop_bridge_dhcp() {
    print_status "Полная остановка моста и DHCP..."

    pkill -f "dnsmasq" 2>/dev/null
    killall -9 dnsmasq 2>/dev/null || true

    iptables -t nat -F 2>/dev/null
    iptables -t mangle -F 2>/dev/null
    iptables -F 2>/dev/null
    iptables -X 2>/dev/null

    echo 0 > /proc/sys/net/ipv4/ip_forward
    sed -i '/net\.ipv4\.ip_forward/d' /etc/sysctl.conf

    if ip link show "$BRIDGE_NAME" &>/dev/null; then
        print_status "Остановка и удаление моста $BRIDGE_NAME..."
        ip link set "$BRIDGE_NAME" down 2>/dev/null || true
        brctl delif "$BRIDGE_NAME" "$ETH_INTERFACE" 2>/dev/null || true
        brctl delbr "$BRIDGE_NAME" 2>/dev/null || true
    else
        print_status "Мост $BRIDGE_NAME не существует, пропускаем удаление..."
    fi

    rm -f $TEMP_DHCP_CONFIG 2>/dev/null
    rm -f /etc/dnsmasq.conf 2>/dev/null
    rm -f /var/lib/misc/dnsmasq.leases 2>/dev/null

    print_status "Полная остановка завершена"
}

set_static_ip() {
    local mac_address="$1"
    local ip_address="$2"

    if [ -z "$mac_address" ] || [ -z "$ip_address" ]; then
        print_error "Использование: $0 static-ip <MAC-адрес> <IP-адрес>"
        print_error "Пример: $0 static-ip aa:bb:cc:dd:ee:ff 192.168.100.100"
        return 1
    fi

    if ! [[ $mac_address =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
        print_error "Неверный формат MAC-адреса: $mac_address"
        return 1
    fi

    if ! [[ $ip_address =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        print_error "Неверный формат IP-адреса: $ip_address"
        return 1
    fi

    print_status "Добавление статического IP $ip_address для MAC $mac_address..."

    local dnsmasq_config="/etc/dnsmasq.conf"
    if [ -f "$dnsmasq_config" ]; then
        if ! grep -q "dhcp-host=$mac_address,$ip_address" "$dnsmasq_config"; then
            sed -i "/# Added by ethernet-bridge for static IPs/a dhcp-host=$mac_address,$ip_address" "$dnsmasq_config" 2>/dev/null || \
            echo "dhcp-host=$mac_address,$ip_address" >> "$dnsmasq_config"
        else
            print_status "Запись для MAC $mac_address уже существует"
        fi
    fi

    save_config_with_static_ip "$mac_address" "$ip_address"

    restart_bridge_if_needed

    print_status "Статический IP $ip_address назначен для MAC $mac_address"
}

save_config_with_static_ip() {
    local mac_address="$1"
    local ip_address="$2"
    local config_backup="$CONFIG_FILE.backup"
    cp "$CONFIG_FILE" "$config_backup" 2>/dev/null || true

    {
        grep -v "^STATIC_IP_" "$config_backup" 2>/dev/null || echo "# Configuration for ethernet-bridge"

        echo ""
        echo "# STATIC IP CONFIGURATION"
        grep -E "^STATIC_IP_" "$config_backup" 2>/dev/null | while read -r line; do
            if [[ $line == STATIC_IP_* ]]; then
                echo "$line"
            fi
        done
        local next_number=1
        while [ -n "$(eval echo \${STATIC_IP_MAC$next_number:-})" ]; do
            next_number=$((next_number+1))
        done

        if [ $next_number -eq 1 ]; then
            echo "STATIC_IP_MAC=\"$mac_address,$ip_address\""
        else
            echo "STATIC_IP_MAC$next_number=\"$mac_address,$ip_address\""
        fi
    } > "$CONFIG_FILE"

    print_status "Конфигурация обновлена с новым статическим IP"
}

limit_bandwidth() {
    local rate="$1"

    if [ -z "$rate" ]; then
        print_error "Использование: $0 limit-bandwidth <скорость>"
        print_error "Пример: $0 limit-bandwidth 10mbit (ограничить до 10 Мбит/с)"
        return 1
    fi

    if ! command -v tc &> /dev/null; then
        print_error "Пакет tc не установлен. Установите его: apt install iproute2"
        return 1
    fi

    print_status "Настройка ограничения пропускной способности на $rate..."

    tc qdisc add dev $BRIDGE_NAME root handle 1: htb default 30 2>/dev/null || \
    tc qdisc replace dev $BRIDGE_NAME root handle 1: htb default 30 2>/dev/null

    tc class add dev $BRIDGE_NAME parent 1: classid 1:1 htb rate "$rate" 2>/dev/null
    tc class add dev $BRIDGE_NAME parent 1:1 classid 1:10 htb rate "$rate" ceil "$rate" 2>/dev/null

    tc filter add dev $BRIDGE_NAME protocol ip parent 1:0 prio 1 u32 match ip dst 192.168.100.0/24 flowid 1:10 2>/dev/null
    tc filter add dev $BRIDGE_NAME protocol ip parent 1:0 prio 1 u32 match ip src 192.168.100.0/24 flowid 1:10 2>/dev/null

    BANDWIDTH_LIMIT="$rate"
    save_config

    restart_bridge_if_needed

    print_status "Пропускная способность ограничена до $rate"
}

remove_bandwidth_limit() {
    if command -v tc &> /dev/null; then
        tc qdisc del dev $BRIDGE_NAME root 2>/dev/null || true

        BANDWIDTH_LIMIT=""
        save_config

        print_status "Ограничение пропускной способности снято"
    fi
}

open_port() {
    local port="$1"
    if [ -z "$port" ]; then
        print_error "Укажите номер порта: $0 port open <номер_порта>"
        return 1
    fi

    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        print_error "Неверный номер порта: $port"
        return 1
    fi

    if iptables -C FORWARD -p tcp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null ||
       iptables -C FORWARD -p udp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null; then
        print_status "Порт $port уже открыт"
        add_port_to_config "$port"
        return 0
    fi

    print_status "Открытие порта $port для доступа к подключенным устройствам..."
    iptables -A FORWARD -p tcp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null || true
    iptables -A FORWARD -p udp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null || true

    add_port_to_config "$port"

    print_status "Порт $port открыт для доступа"
}

add_port_to_config() {
    local port="$1"

    if [ -z "${OPEN_PORTS:-}" ]; then
        OPEN_PORTS="$port"
    else
        if ! echo "$OPEN_PORTS" | grep -q "\b$port\b"; then
            OPEN_PORTS="$OPEN_PORTS,$port"
        fi
    fi

    save_config
}

close_port() {
    local port="$1"
    if [ -z "$port" ]; then
        print_error "Укажите номер порта: $0 port close <номер_порта>"
        return 1
    fi

    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        print_error "Неверный номер порта: $port"
        return 1
    fi

    print_status "Закрытие порта $port для доступа к подключенным устройствам..."

    iptables -D FORWARD -p tcp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null || true
    iptables -D FORWARD -p udp --dport "$port" -d 192.168.100.0/24 -j ACCEPT 2>/dev/null || true

    remove_port_from_config "$port"

    print_status "Порт $port закрыт для доступа"
}

remove_port_from_config() {
    local port="$1"

    if [ -n "${OPEN_PORTS:-}" ]; then
        OPEN_PORTS=$(echo "$OPEN_PORTS" | sed "s/\b$port\b//g" | sed 's/,,/,/g' | sed 's/^,//' | sed 's/,$//')

        if [ "$OPEN_PORTS" = "" ] || [ "$OPEN_PORTS" = "," ]; then
            OPEN_PORTS=""
        fi
    fi

    save_config
}

list_open_ports() {
    echo "=== Открытые порты для доступа к подключенным устройствам ==="

    local tcp_ports=$(iptables -L FORWARD -n -v --line-numbers | grep -E "ACCEPT.*192.168.100.0/24.*dpt:" | grep tcp | grep -oE "dpt:[0-9]+" | cut -d: -f2 | sort -n | uniq)
    local udp_ports=$(iptables -L FORWARD -n -v --line-numbers | grep -E "ACCEPT.*192.168.100.0/24.*dpt:" | grep udp | grep -oE "dpt:[0-9]+" | cut -d: -f2 | sort -n | uniq)

    if [ -n "$tcp_ports" ]; then
        echo "TCP порты:"
        echo "$tcp_ports" | while read -r port; do
            if [ -n "$port" ]; then
                echo "  $port (TCP)"
            fi
        done
    else
        echo "TCP порты: нет открытых"
    fi

    if [ -n "$udp_ports" ]; then
        echo "UDP порты:"
        echo "$udp_ports" | while read -r port; do
            if [ -n "$port" ]; then
                echo "  $port (UDP)"
            fi
        done
    else
        echo "UDP порты: нет открытых"
    fi
}

set_dns() {
    local dns_server="$1"

    if [ -z "$dns_server" ]; then
        print_error "Использование: $0 set-dns <DNS-сервер>"
        print_error "Пример: $0 set-dns 8.8.8.8"
        return 1
    fi

    if ! [[ $dns_server =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        print_error "Неверный формат IP-адреса: $dns_server"
        return 1
    fi

    print_status "Настройка DNS-сервера $dns_server для подключенных устройств..."

    DNS_SERVER="$dns_server"

    save_config

    local dnsmasq_config="/etc/dnsmasq.conf"

    sed -i '/^dhcp-option=option:dns-server/d' "$dnsmasq_config" 2>/dev/null

    if [ -f "$dnsmasq_config" ]; then
        sed -i "/interface=$BRIDGE_NAME/a dhcp-option=option:dns-server,$dns_server" "$dnsmasq_config"
    else
        print_error "Файл конфигурации dnsmasq не найден"
        return 1
    fi

    restart_bridge_if_needed

    print_status "DNS-сервер $dns_server установлен для подключенных устройств"
}

show_logs() {
    echo "=== Сетевые логи ==="

    echo "Лог dnsmasq:"
    if [ -f /var/log/dnsmasq.log ]; then
        tail -n 20 /var/log/dnsmasq.log 2>/dev/null || echo "Файл лога не найден"
    elif [ -f /tmp/dnsmasq.log ]; then
        tail -n 20 /tmp/dnsmasq.log 2>/dev/null
    else
        if command -v journalctl &> /dev/null; then
            journalctl -u dnsmasq --no-pager -n 20 2>/dev/null || echo "Лог dnsmasq не найден"
        else
            echo "Лог dnsmasq не найден в стандартных местах (/var/log/dnsmasq.log, /tmp/dnsmasq.log) и journalctl недоступен"
        fi
    fi

    echo ""
    echo "Недавние сетевые сообщения ядра:"
    if command -v dmesg &> /dev/null; then
        dmesg | grep -i "bridge\|network\|eth\|wlan" | tail -n 10
    fi

    echo ""
    echo "Состояние интерфейсов:"
    ip link show $BRIDGE_NAME 2>/dev/null || echo "Мост $BRIDGE_NAME не существует"
    ip addr show $BRIDGE_NAME 2>/dev/null

    echo ""
    echo "Таблица маршрутизации:"
    ip route | grep -E "(192.168.100|br0|bridge)" || echo "Специфические маршруты не найдены"
}

show_iptables_rules() {
    echo "=== Активные правила iptables ==="
    if command -v iptables &> /dev/null; then
        echo "Правила NAT:"
        iptables -t nat -L -n -v 2>/dev/null | grep -A 20 "$WIFI_INTERFACE\|$BRIDGE_NAME" || echo "Нет специфических правил NAT для моста"
        echo ""
        echo "Правила FORWARD:"
        iptables -L FORWARD -n -v 2>/dev/null | grep -A 20 "$WIFI_INTERFACE\|$BRIDGE_NAME" || echo "Нет специфических правил FORWARD для моста"
        echo ""
        echo "Все правила (фильтр по мосту):"
        iptables -L -n -v 2>/dev/null | grep -i "$BRIDGE_NAME"
    else
        echo "iptables не установлен"
    fi
}

show_devices() {
    echo "=== Подключенные устройства ==="
    if ip link show $BRIDGE_NAME >/dev/null 2>&1; then
        echo "Интерфейсы, подключенные к мосту $BRIDGE_NAME:"
        bridge link show | grep -A 10 "$BRIDGE_NAME" 2>/dev/null || brctl show $BRIDGE_NAME 2>/dev/null
        echo ""
        if [ -f /var/lib/misc/dnsmasq.leases ]; then
            echo "Аренда DHCP:"
            cat /var/lib/misc/dnsmasq.leases 2>/dev/null | while read -r line; do
                if [ -n "$line" ]; then
                    read -r time ip mac hostname rest <<< "$line"
                    echo "IP: $ip, MAC: $mac, Hostname: $hostname, Time: $(date -d @$time 2>/dev/null || echo $time)"
                fi
            done
        else
            echo "Нет активных аренд DHCP"
        fi
        echo ""
        echo "Состояние интерфейсов моста:"
        ip link show $BRIDGE_NAME 2>/dev/null | grep -E "(UP|LOWER_UP)" && echo "Мост активен" || echo "Мост неактивен"
        echo ""
        echo "IP-адреса на мосте:"
        ip addr show $BRIDGE_NAME 2>/dev/null | grep inet || echo "IP-адрес не назначен"
    else
        echo "Мост $BRIDGE_NAME не существует или не активен"
    fi
}

show_status() {
    echo "=== Статус моста ==="
    echo "IP forwarding: $(cat /proc/sys/net/ipv4/ip_forward)"
    echo "Мост: $(ip addr show $BRIDGE_NAME 2>/dev/null && echo 'активен' || echo 'неактивен')"
    echo "DHCP: $(pgrep -f 'dnsmasq.*-C /etc/dnsmasq.conf' && echo 'работает' || echo 'не работает')"
    if [ -f /var/lib/misc/dnsmasq.leases ]; then
        echo "DHCP аренды:"
        cat /var/lib/misc/dnsmasq.leases 2>/dev/null
    fi
}

main() {
    check_root
    load_config
    check_dependencies

    case "$1" in
        "start"|"setup")
            detect_interfaces
            setup_bridge_dhcp
            ;;
        "stop")
            stop_bridge_dhcp
            ;;
        "status")
            detect_interfaces 2>/dev/null
            show_status
            ;;
        "restart")
            detect_interfaces 2>/dev/null
            stop_bridge_dhcp
            sleep 2
            setup_bridge_dhcp
            ;;
        "devices")
            show_devices
            ;;
        "rules")
            show_iptables_rules
            ;;
        "port")
            case "$2" in
                "open")
                    open_port "$3"
                    ;;
                "close")
                    close_port "$3"
                    ;;
                "list-open")
                    list_open_ports
                    ;;
                *)
                    print_error "Использование: $0 port {open|close|list-open} [порт]"
                    ;;
            esac
            ;;
        "static-ip")
            set_static_ip "$2" "$3"
            ;;
        "limit-bandwidth")
            limit_bandwidth "$2"
            ;;
        "remove-bandwidth-limit")
            remove_bandwidth_limit
            ;;
        "logs")
            show_logs
            ;;
        "set-dns")
            set_dns "$2"
            ;;
        "autostart")
            case "$2" in
                "enable")
                    create_autostart
                    ;;
                "disable")
                    remove_autostart
                    ;;
                *)
                    print_error "Использование: $0 autostart {enable|disable}"
                    ;;
            esac
            ;;
        "info")
            show_command_info "$2"
            ;;
        *)
            echo "Использование: $0 <команда> [параметры]"
            echo ""
            echo "╭─УПРАВЛЕНИЕ МОСТОМ─────────────────────────╮"
            echo "│ start                                     │"
            echo "│ stop                                      │"
            echo "│ restart                                   │"
            echo "│ status                                    │"
            echo "╰───────────────────────────────────────────╯"
            echo ""
            echo "╭─ИНФОРМАЦИЯ И СТАТУС───────────────────────╮"
            echo "│ devices                                   │"
            echo "│ rules                                     │"
            echo "│ logs                                      │"
            echo "╰───────────────────────────────────────────╯"
            echo ""
            echo "╭─УПРАВЛЕНИЕ ПОРТАМИ────────────────────────╮"
            echo "│ port open <порт>                          │"
            echo "│ port close <порт>                         │"
            echo "│ port list-open                            │"
            echo "╰───────────────────────────────────────────╯"
            echo ""
            echo "╭─КОНФИГУРАЦИЯ ПОДКЛЮЧЕНИЙ──────────────────╮"
            echo "│ static-ip <MAC> <IP>                      │"
            echo "│ set-dns <IP>                              │"
            echo "╰───────────────────────────────────────────╯"
            echo ""
            echo "╭─СЕТЕВЫЕ НАСТРОЙКИ─────────────────────────╮"
            echo "│ limit-bandwidth <rate>                    │"
            echo "│ remove-bandwidth-limit                    │"
            echo "╰───────────────────────────────────────────╯"
            echo ""
            echo "╭─СИСТЕМНЫЕ НАСТРОЙКИ───────────────────────╮"
            echo "│ autostart enable                          │"
            echo "│ autostart disable                         │"
            echo "│ info <команда>                            │"
            echo "╰───────────────────────────────────────────╯"
            ;;
    esac
}

main "$@"